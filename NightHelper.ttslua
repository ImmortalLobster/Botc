--[[
Night Tool
Made by Sionar
--]]


------------------Constants
VERSION = '2.0.0'
COLORS = {'White', 'Brown', 'Red', 'Orange', 'Yellow', 'Green', 'Teal', 'Blue', 'Purple', 'Pink', 'Magenta', 'Lavender', 'Navy', 'Cyan', 'Mint', 'Lime', 'Peach', 'Coral', 'Maroon', 'Silver'}
COLORS_BBC = {White = '[FFFFFF]', Brown = '[703A16]', Red = '[DA1917]', Orange = '[F3631C]', Yellow = '[E6E42B]', Green = '[30B22A]', Teal = '[20B09A]', Blue = '[1E87FF]', Purple = '[9F1FEF]', Pink = '[F46FCD]', Magenta = '[FF007F]', Lavender = '[967BB6]', Navy = '[616BD4]', Cyan = '[49D5FD]', Mint = '[89C381]', Lime = '[B8F161]', Peach = '[F1D4A2]', Coral = '[E29A8A]', Maroon = '[800000]', Silver = '[BEBEBE]'}
COLORS_RGB = {White = {1,1,1}, Brown = {113/255,59/255,23/255}, Red = {219/255,26/255,24/255}, Orange = {244/255,100/255,29/255}, Yellow = {231/255,229/255,44/255}, Green = {49/255,179/255,43/255}, Teal = {33/255,177/255,155/255}, Blue = {31/255,136/255,255/255}, Purple = {160/255,32/255,240/255}, Pink = {245/255,112/255,206/255}, Magenta = {255/255,0/255,127/255}, Lavender = {150/255,123/255,182/255}, Navy = {97/255,107/255,212/255}, Cyan = {73/255,213/255,253/255}, Mint = {137/255,195/255,129/255}, Lime = {184/255,241/255,97/255}, Peach = {241/255,212/255,162/255}, Coral = {226/255,154/255,138/255}, Maroon = {128/255,0,0}, Silver = {190/255,190/255,190/255},}
START_POS = {0,1.11,107}

ROW_S = -7.3
ROW_W = 0.45
FONT_SIZE = 225
FONT_SIZE_LABEL = 360
BUTTON_SIZE = 270
BUTTON_Y = 0.1
COLUMN = {-6, -4, -3.35, -2.70, -2.05, -1.5, 3.6, 6.3}
ROW = {}
for i = 1,40 do
    ROW[i] = ROW_S + i * ROW_W
end
LIVING_LAB_Z = -7.75
NIGHT_LAB_Z = -7.75
PREVIEW_LAB_Z = 2.35
PREVIEW_MSG_Z = 3.7
ADDCHAR_LAB_X = -4.95
ADDCHAR_LAB_Z = 5.1
ADD_BUT_X = -1.9
INPUTS_X = {-6.6, -3.45, 0.3, 3.6, 6.9}
INPUTS_LAB_Z = 5.775
INPUT_BUT_Z = 6.45
BOTTOM_BUT_X = {-5, -2.5, 0, 2.5, 5}
BOTTOM_BUT_Z = 7.75

CLOCK_CONTROLS_GUID = '184d11'


------------------Variables
living = {}
order = {}
orderRef = nil
minionColors = {}
demonColor = nil
lastBlind = ''
blindAuto = true
checkPrompts = true
message = ''
charAdd = ''
colorAdd = ''
currentMsg = ''
sendMsg = ''
evilMsg = ''
p1, p2, p3 = '', '', ''
dayNum = 0

------------------Load/save
function onLoad(saveString)
    moveBoard()
    if not (saveString == '') then
        local save = JSON.decode(saveString)
        living = save['l']
        order = save['o']
        orderRef = save['r']
        demonColor = save['d']
        lastBlind = save['lb']
        checkPrompts = save['c']
        blindAuto = save['b']
        dayNum = save['day']
    end
    refreshUI()
    self.setDescription('v ' .. VERSION .. '\nMade by Sionar')
end

function onSave()
    local save = {}
    save['l'] = living
    save['o'] = order
    save['r'] = orderRef
    save['d'] = demonColor
    save['lb'] = lastBlind
    save['c'] = checkPrompts
    save['b'] = blindAuto
    save['day'] = dayNum
    local saveString = JSON.encode(save)
    return saveString
end


------------------Functions
function moveBoard()
    local modName = Global.getVar('MOD_NAME')
    if modName == 'Blood on the Clocktower' then
        self.setPositionSmooth(START_POS)
        self.setLock(true)
    end
end

function import()
    local chars = Global.getTable('chars')
    local numChars = 0
    local lunaticColor = false
    local tempDemonColor
    local demonName
    local found = false

    for k,v in pairs(chars) do
        numChars = numChars + 1
    end
    if numChars == 0 then
        return
    end
    local entry = {}
    living = {}
    minionColors = {}
    for k,v in pairs(chars) do
        playerChar = string.gsub(v, ' ', '_')
        entry = {color = k, char = playerChar, used = false, alive = true, sober = true, sane = true}
        table.insert(living, entry)
        if CHARACTERS[playerChar].Type == 'Minion' then
            found = false
            for k1,v1 in pairs(minionColors) do
                if v1 == entry.color then
                    found = true
                    break
                end
            end
            if not found then
                table.insert(minionColors, entry.color)
            end
        elseif CHARACTERS[playerChar].Type == 'Demon' then
            demonColor = entry.color
            demonName = entry.char
        end
    end
    for k,v in pairs(living) do
        if v.char == 'Lunatic' then
            lunaticColor = v.color
            tempDemonColor = demonColor
            demonColor = lunaticColor
            v.char = demonName
            for k1,v1 in pairs(living) do
                if v1.color == tempDemonColor then
                    v1.char = 'Lunatic'
                    break
                end
            end
            break
        end
    end

    local minionStr = 'Minions:'
    for i = 1, #minionColors do
        minionStr = minionStr .. ' ' .. COLORS_BBC[minionColors[i]] .. minionColors[i] .. '[-]'
    end
    evilMsg = 'Demon: ' .. COLORS_BBC[demonColor] .. demonColor .. '[-], ' .. minionStr
    setNightOrder('first')
    setMsg()
end

function setNightOrder(night)
    order = {}
    local players = Global.call('updatePlayers')
    if blindAuto then
        if lastBlind ~= '' then
            if players[lastBlind] ~= nil then
                players[lastBlind].blindfolded = true
            end
            lastBlind = ''
        end
    end
    if night == 'first' then
        table.insert(order, {char = 'Evil_Info', color = 'White'})
        table.insert(order, {char = 'Demon_Info', color = demonColor})
        orderRef = FIRST
    else
        orderRef = OTHER
    end
    for k1,v1 in pairs(orderRef) do
        for k2,v2 in pairs(living) do
            if v2.char == v1 and v2.char ~= 'Ravenkeeper' and v2.char ~= 'Sage' and v2.char ~= 'Barber' and v2.char ~= 'Cartographer' then
                if v2.alive and (CHARACTERS[v2.char].Ability == false or (CHARACTERS[v2.char].Ability == true and v2.used == false)) then
                    if v2.char == 'Lunatic' and night == 'first' then
                        table.insert(order, 1, {char = 'Lunatic_InfoA', color = v2.color})
                        table.insert(order, 2, {char = 'Lunatic_InfoB', color = v2.color})
                        table.insert(order, 3, {char = 'Lunatic_InfoC', color = demonColor})
                        table.insert(order, v2)
                    elseif v2.char == 'Lunatic' and night == 'other' then
                        table.insert(order, v2)
                        table.insert(order, {char = 'Lunatic_InfoD', color = demonColor})
                    elseif v2.char == 'Godfather' and night == 'first' then
                        table.insert(order, {char = 'Godfather_Info', color = v2.color})
                    elseif v2.char == 'Rakshasa' and night == 'other' then
                        table.insert(order, v2)
                        table.insert(order, {char = 'Rakshasa_Kill', color = v2.color})
                    elseif v2.char == 'Ysbaddaden' and night == 'other' then
                        table.insert(order, v2)
                        table.insert(order, {char = 'Ysbaddaden_Kill', color = v2.color})
                    elseif v2.char == 'Jabberwocky' and night == 'other' then
                        table.insert(order, v2)
                        table.insert(order, {char = 'Jabberwocky_Kill', color = v2.color})
                    else
                        table.insert(order, v2)
                    end
                end
            end
        end
    end

    for k,v in pairs(living) do
        if not v.sane then
            table.insert(order, {char = 'Madness', color = v.color})
        end
    end

    table.insert(order, {char = 'Next_Night', color = 'White'})
    sortOrder()
    setMsg()
end

function sortOrder()
    local sortedOrder = {}
    for k,v in pairs(orderRef) do
        for k1,v1 in pairs(order) do
            if v == v1.char then
                table.insert(sortedOrder, v1)
            end
        end
    end
    order = sortedOrder
end

function setMsg()
    if #order == 0 then
        currentMsg = ''
        sendMsg = ''
        refreshUI()
        return
    end
    local currentChar = order[1].char
    if currentChar == 'Evil_Info' then
        currentMsg = evilMsg
    elseif currentChar == 'Next_Night' then
        currentMsg = ''
    else
        currentMsg = CHARACTERS[currentChar].Prompt
    end
    sendMsg = removeUnder(currentMsg)
    refreshUI()
end

function getKey(table, value)
    for k,v in pairs(table) do
        if value == v then
            return k
        end
    end
    return nil
end

function inTable(table, value)
    for k,v in pairs(table) do
        if v == value then
            return true
        end
    end
    return false
end

function used(clickedObject, playerColor, i)
    local entry = living[i]
    local char = string.gsub(living[i].char, ' ', '_')
    living[i].used = not living[i].used
    if CHARACTERS[char].Ability == true and living[i].used == true then
        for k,v in pairs(order) do
            if living[i].char == v.char then
                table.remove(order, k)
            end
        end
    end
    setMsg()
end

for k = 1,30 do
    _G['used' .. k] = function(obj, col)
        used(obj, col, k)
    end
end

function alive(clickedObject, playerColor, i)
    local entry = living[i]
    living[i].alive = not living[i].alive

    if not living[i].alive and (entry.char == 'Ravenkeeper' or entry.char == 'Sage' or entry.char == 'Barber' or entry.char == 'Cartographer') then
        if orderRef ~= nil then
            orderIndex = getKey(orderRef, entry.char)
            if orderIndex == nil then
                refreshUI()
                return
            end
            for i = 1, #order do
                if orderIndex < getKey(orderRef, order[i].char) then
                    orderPos = i
                    break
                end
            end
            if orderPos == nil then
                orderPos = #order + 1
            end
            if entry.char == 'Barber' or entry.char == 'Cartographer' then
                entry.color = demonColor
            end
            table.insert(order, orderPos, {color = entry.color, char = entry.char})
        end
    else
        if order ~= nil then
            for k,v in pairs(order) do
                if v.char == entry.char then
                    table.remove(order, k)
                    break
                end
            end
            if entry.char == 'Lunatic' then
                for i = #order,1,-1 do
                    if string.match(order[i].char, 'Lunatic') then
                        table.remove(order, i)
                    end
                end
            elseif entry.char == 'Godfather' then
                for i = #order,1,-1 do
                    if string.match(order[i].char, 'Godfather') then
                        table.remove(order, i)
                    end
                end
            end
        end
    end

    setMsg()
end

for k = 1,30 do
    _G['alive' .. k] = function(obj, col)
        alive(obj, col, k)
    end
end

function sober(clickedObject, playerColor, i)
    living[i].sober = not living[i].sober
    setMsg()
end

for k = 1,30 do
    _G['sober' .. k] = function(obj, col)
        sober(obj, col, k)
    end
end

function sane(clickedObject, playerColor, i)
    local entry = living[i]
    local char = string.gsub(living[i].char, ' ', '_')
    local found = false

    living[i].sane = not living[i].sane

    if living[i].sane then
        for k,v in pairs(order) do
            if v.char == 'Madness' and v.color == entry.color then
                table.remove(order,k)
            end
        end
    else
        for k,v in pairs(order) do
            if v.char == 'Madness' and v.color == entry.color then
                found = true
                break
            end
        end
        if not found then
            table.insert(order, {char = 'Madness', color = entry.color})
            sortOrder()
        end
    end
    setMsg()
end

for k = 1,30 do
    _G['sane' .. k] = function(obj, col)
        sane(obj, col, k)
    end
end


function remove(clickedObject, playerColor, i)
    local entry = living[i]
    table.remove(living, i)

    for k,v in pairs(minionColors) do
        if v == entry.color then
            table.remove(minionColors,k)
            local minionStr = 'Minions:'
            for i = 1, #minionColors do
                minionStr = minionStr .. ' ' .. COLORS_BBC[minionColors[i]] .. minionColors[i] .. '[-]'
            end
            evilMsg = 'Demon: ' .. COLORS_BBC[demonColor] .. demonColor .. '[-], ' .. minionStr
        end
    end
    setMsg()
end

for k = 1,30 do
    _G['remove' .. k] = function(obj, col)
        remove(obj, col, k)
    end
end

function send(clickedObject, playerColor)
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    local steam_name = Player[playerColor].steam_name
    local sendColor, msg
    local players = Global.call('updatePlayers')
    local allBlind = clockControls.getVar('allBlind')

    if order[1].char == 'Evil_Info' then
        msg = COLORS_BBC[demonColor] .. '<' .. demonColor .. '>[-] [000000]' .. steam_name .. ':[-] ' .. evilMsg
        if players[demonColor] ~= nil then
            players[demonColor].print(msg)
        end
        printToColor(msg, 'Black', {1,1,1})
        for i = 1, #minionColors do
            msg = COLORS_BBC[minionColors[i]] .. '<' .. minionColors[i] .. '>[-] [000000]' .. steam_name .. ':[-] ' .. evilMsg
            if players[minionColors[i]] ~= nil then
                players[minionColors[i]].print(msg)
            end
            printToColor(msg, 'Black', {1,1,1})
        end
    elseif order[1].char == 'Next_Night' then
        if blindAuto then
            if lastBlind ~= '' then
                if players[lastBlind] ~= nil then
                    if allBlind then
                        players[lastBlind].blindfolded = true
                    end
                end
                lastBlind = ''
            end
        end
        setNightOrder('other')
        setMsg()
        dayNum = dayNum + 1
        local history = Global.getVar('history')
        history = history .. '\n[808080]----------Day ' .. dayNum .. '----------[-]'
        Global.setVar('history', history)
        return
    else
        if checkPrompts then
            if string.match(sendMsg, 'P1') or string.match(sendMsg, 'P2') or string.match(sendMsg, 'P3') then
                Player[playerColor].print('Error: Fill in the prompts before sending the message.', {1,0,0})
                setMsg()
                return
            end
        end
        sendColor = order[1].color
        msg = COLORS_BBC[sendColor] .. '<' .. sendColor .. '>[-] [000000]' .. steam_name .. ':[-] ' .. sendMsg
        if players[sendColor] ~= nil then
            players[sendColor].print(msg)
        end
        printToColor(msg, 'Black', {1,1,1})
        if blindAuto and order[1].char ~= 'Lunatic_InfoA' then
            if lastBlind == '' then
                lastBlind = order[1].color
                if players[lastBlind] ~= nil then
                    players[lastBlind].blindfolded = false
                end
            else
                if players[lastBlind] ~= nil then
                    players[lastBlind].blindfolded = true
                end
                lastBlind = order[1].color
                if players[lastBlind] ~= nil then
                    players[lastBlind].blindfolded = false
                end
            end
        end
    end
    table.remove(order, 1)
    setMsg()
end

function skip(clickedObject, playerColor, i)
    table.remove(order, i)
    setMsg()
end

for k = 1,30 do
    _G['skip' .. k] = function(obj, col)
        skip(obj, col, k)
    end
end

function nullFunc() end

function firstNight(clickedObject, playerColor)
    setNightOrder('first')
end

function otherNight(clickedObject, playerColor)
    setNightOrder('other')
end

function charInput(obj, color, input, stillEditing)
    if not stillEditing then
        for k,v in pairs(CHARACTERS) do
            if string.lower(k) == string.lower(input) and input ~= '' then
                charAdd = k
                break
            end
            if string.match(string.lower(k), string.lower(input)) and input ~= '' then
                charAdd = k
                break
            end
        end
        refreshUI()
        return 1
    end
end

function colorInput(obj, color, input, stillEditing)
    if not stillEditing then
        for k,v in pairs(COLORS) do
            if string.match(string.lower(v), string.lower(input)) and input ~= '' then
                colorAdd = v
                break
            end
        end
        refreshUI()
        return 1
    end
end

function p1Input(obj, color, input, stillEditing)
    if not stillEditing then
        if input == '' then
            p1 = 'P1'
            return
        end
        local textColor
        local found = false
        for k,v in pairs(COLORS) do
            if string.match(string.lower(v), string.lower(input)) then
                p1 = COLORS_BBC[v] .. v .. '[-]'
                found = true
                break
            end
        end
        for k,v in pairs(CHARACTERS) do
            if string.match(string.lower(k), string.lower(string.gsub(input,' ', '_'))) then
                if v.Type == 'Townsfolk' then
                    textColor = COLORS_BBC['Blue']
                elseif v.Type == 'Outsider' then
                    textColor = COLORS_BBC['Teal']
                elseif v.Type == 'Minion' then
                    textColor = COLORS_BBC['Orange']
                elseif v.Type == 'Demon' then
                    textColor = COLORS_BBC['Red']
                elseif v.Type == 'Traveler' then
                    textColor = COLORS_BBC['Green']
                elseif v.Type == 'Status' then
                    textColor = COLORS_BBC['Purple']
                end
                p1 = removeUnder(textColor .. k .. '[-]')
                found = true
                break
            end
        end
        if not found then
            p1 = input
        end
        editMsg()
        return 1
    end
end

function p2Input(obj, color, input, stillEditing)
    if not stillEditing then
        if input == '' then
            p2 = 'P2'
            return
        end
        local textColor
        local found = false
        for k,v in pairs(COLORS) do
            if string.match(string.lower(v), string.lower(input)) then
                p2 = COLORS_BBC[v] .. v .. '[-]'
                found = true
                break
            end
        end
        for k,v in pairs(CHARACTERS) do
            if string.match(string.lower(k), string.lower(input)) then
                if v.Type == 'Townsfolk' then
                    textColor = COLORS_BBC['Blue']
                elseif v.Type == 'Outsider' then
                    textColor = COLORS_BBC['Teal']
                elseif v.Type == 'Minion' then
                    textColor = COLORS_BBC['Orange']
                else
                    textColor = COLORS_BBC['Red']
                end
                p2 = removeUnder(textColor .. k .. '[-]')
                found = true
                break
            end
        end
        if not found then
            p2 = input
        end
        editMsg()
        return 1
    end
end

function p3Input(obj, color, input, stillEditing)
    if not stillEditing then
        if input == '' then
            p3 = ''
            return
        end
        local textColor
        local found = false
        for k,v in pairs(COLORS) do
            if string.match(string.lower(v), string.lower(input)) then
                p3 = COLORS_BBC[v] .. v .. '[-]'
                found = true
                break
            end
        end
        for k,v in pairs(CHARACTERS) do
            if string.match(string.lower(k), string.lower(input)) then
                if v.Type == 'Townsfolk' then
                    textColor = COLORS_BBC['Blue']
                elseif v.Type == 'Outsider' then
                    textColor = COLORS_BBC['Teal']
                elseif v.Type == 'Minion' then
                    textColor = COLORS_BBC['Orange']
                else
                    textColor = COLORS_BBC['Red']
                end
                p3 = removeUnder(textColor .. k .. '[-]')
                found = true
                break
            end
        end
        if not found then
            p3 = input
        end
        editMsg()
        return 1
    end
end

function editMsg()
    local msg = currentMsg
    msg = string.gsub(msg, 'P1', p1)
    msg = string.gsub(msg, 'P2', p2)
    msg = string.gsub(msg, 'P3', p3)
    sendMsg = removeUnder(msg)
    refreshUI()
end

function addChar(clickedObject, playerColor)
    if colorAdd == '' or charAdd == '' then
        broadcastToColor('ERROR: The character or color field is empty.', playerColor, {1,0,0})
        return
    end
    local pos, colorIndex
    local orderPos, orderIndex
    local found

    if #living == 0 then
        pos = 1
    else
        colorIndex = getKey(COLORS, colorAdd)
        for i = 1, #living do
            if colorIndex < getKey(COLORS, living[i].color) then
                pos = i
                break
            end
        end
        if pos == nil then
            pos = #living + 1
        end
    end
    table.insert(living, pos, {color = colorAdd, char = charAdd, used = false, alive = true, sober = true, sane = true})
    if charAdd == 'Ravenkeeper' or charAdd == 'Sage' or charAdd == 'Barber' then
        refreshUI()
        return
    end
    if CHARACTERS[charAdd].Type == 'Demon' or CHARACTERS[charAdd].Type == 'Minion' then
        if CHARACTERS[charAdd].Type == 'Demon' then
            demonColor = colorAdd
        elseif CHARACTERS[charAdd].Type == 'Minion' then
            found = false
            for k,v in pairs(minionColors) do
                if v == colorAdd then
                    found = true
                    break
                end
            end
            if not found then
                table.insert(minionColors, colorAdd)
            end
        end
        local minionStr = 'Minions:'
        for i = 1, #minionColors do
            minionStr = minionStr .. ' ' .. COLORS_BBC[minionColors[i]] .. minionColors[i] .. '[-]'
        end
        evilMsg = 'Demon: ' .. COLORS_BBC[demonColor] .. demonColor .. '[-], ' .. minionStr
    end
    if orderRef ~= nil then
        orderIndex = getKey(orderRef, charAdd)
        if orderIndex == nil then
            refreshUI()
            return
        end
        for i = 1, #order do
            if orderIndex < getKey(orderRef, order[i].char) then
                orderPos = i
                break
            end
        end
        if orderPos == nil then
            orderPos = #order + 1
        end
        table.insert(order, orderPos, {color = colorAdd, char = charAdd})
        if charAdd == 'Lunatic' then
            table.insert(order, 1, {char = 'Lunatic_InfoA', color = colorAdd})
            table.insert(order, 2, {char = 'Lunatic_InfoB', color = colorAdd})
            table.insert(order, 3, {char = 'Lunatic_InfoC', color = demonColor})
            setMsg()
        elseif charAdd == 'Godfather' then
            table.insert(order, 1, {char = 'Godfather_Info', color = colorAdd})
        end
    end
    setMsg()
end

function toggleCheck(clickedObject, playerColor)
    checkPrompts = not checkPrompts
    refreshUI()
    if checkPrompts then
        broadcastToColor('Prompt checking enabled.', playerColor, {1,1,1})
    else
        broadcastToColor('Prompt checking disabled.', playerColor, {1,1,1})
    end
end

function toggleBlind(clickedObject, playerColor)
    blindAuto = not blindAuto
    refreshUI()
    if blindAuto then
        broadcastToColor('Automatic blindfolding enabled.', playerColor, {1,1,1})
    else
        broadcastToColor('Automatic blindfolding disabled.', playerColor, {1,1,1})
    end
end

function format(string)
    local lineMax = 35
    local result
    local lineLen = 0
    local output = ''
    for word in string.gmatch(string, '%g+') do
        if lineLen + string.len(word) + 1 > lineMax then
            output = output .. '\n' .. word
            lineLen = string.len(word)
        else
            if lineLen == 0 then
                output = output .. word
                lineLen = lineLen + string.len(word)
            else
                output = output .. ' ' .. word
                lineLen = lineLen + 1 + string.len(word)
            end
        end
    end
    return output
end

function swapColors(params)
    local color1 = params.color1
    local color2 = params.color2
    local color1Living = false
    local color2Living = false
    local chars = Global.getTable('chars')
    local index, tempUsed

    for i = 1, #living do
        if living[i].color == color1 then
            color1Living = i
        elseif living[i].color == color2 then
            color2Living = i
        end
    end

    if not color1Living and not color2Living then
        return
    end

    if color1Living and color2Living then
        living[color1Living].char = chars[color1]
        living[color2Living].char = chars[color2]
    elseif color1Living and not color2Living then
        table.remove(living, color1Living)
        index = findLivingIndex(color2)
        table.insert(living, index, {color = color2, char = chars[color2]})
    elseif not color1Living and color2Living then
        table.remove(living, color2Living)
        index = findLivingIndex(color1)
        table.insert(living, index, {color = color1, char = chars[color1]})
    end

    setNightOrder('other')
end

function findLivingIndex(color)
    local colorIdx = colorIndex(color)
    local index
    for i = 1, #living do
        index = colorIndex(living[i].color)
        if colorIdx < index then
            return i
        end
    end
    return #living + 1
end

function colorIndex(color)
    local index = 1
    for k,v in pairs(COLORS) do
        if v == color then
            return index
        end
        index = index + 1
    end
    return nil
end

------------------UI
function refreshUI()
    self.clearInputs()
    self.clearButtons()
    local buttonParam = {}
    local inputParam = {}
    local char

    buttonParam = {click_function = 'nullFunc', label = 'Characters', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {-4.5,BUTTON_Y,LIVING_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE_LABEL,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = 'Night Order', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {4.5,BUTTON_Y,NIGHT_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE_LABEL,}
    self.createButton(buttonParam)

    for i = 1, #living do
        buttonParam = {click_function = 'nullFunc', function_owner = self, label = removeUnder(living[i].char), color = {0,0,0,1}, font_color = COLORS_RGB[living[i].color], position = {COLUMN[1],BUTTON_Y,ROW[i]}, width = 0, height = 0, font_size = FONT_SIZE,}
        self.createButton(buttonParam)

        char = string.gsub(living[i].char, ' ', '_')
        if CHARACTERS[char].Ability == true then
            buttonParam = {click_function = 'used'..i, function_owner = self, color = {0,0,0,1}, position = {COLUMN[2],BUTTON_Y,ROW[i]}, width = 3200, height = 2300, font_size = 1200, scale = {0.1,0.1,0.1}}
            if living[i].used == false then
                buttonParam.label = 'Has\nAbility'
                buttonParam.font_color = stringColorToRGB('Blue')
                buttonParam.tooltip = 'Player has one time ability'
            else
                buttonParam.label = 'No\nAbility'
                buttonParam.font_color = stringColorToRGB('Red')
                buttonParam.tooltip = 'Player used their one time ability'
            end
            self.createButton(buttonParam)
        end

        buttonParam = {click_function = 'alive'..i, function_owner = self, color = {0,0,0,1}, position = {COLUMN[3],BUTTON_Y,ROW[i]}, width = 3200, height = 2300, font_size = 1200, scale = {0.1,0.1,0.1}}
        if living[i].alive then
            buttonParam.label = 'Alive'
            buttonParam.font_color = stringColorToRGB('Blue')
            buttonParam.tooltip = 'Player is alive'
        else
            buttonParam.label = 'Dead'
            buttonParam.font_color = stringColorToRGB('Red')
            buttonParam.tooltip = 'Player is dead'
        end
        self.createButton(buttonParam)

        buttonParam = {click_function = 'sober'..i, function_owner = self, color = {0,0,0,1}, position = {COLUMN[4],BUTTON_Y,ROW[i]}, width = 3200, height = 2300, font_size = 1200, scale = {0.1,0.1,0.1}}
        if living[i].sober then
            buttonParam.label = 'Sober/\nHealthy'
            buttonParam.font_color = stringColorToRGB('Blue')
            buttonParam.tooltip = 'Player is sober or healthy'
        else
            buttonParam.label = 'Drunk/\nPoisoned'
            buttonParam.font_color = stringColorToRGB('Red')
            buttonParam.tooltip = 'Player is drunk or poisoned'
        end
        self.createButton(buttonParam)

        buttonParam = {click_function = 'sane'..i, function_owner = self, color = {0,0,0,1}, position = {COLUMN[5],BUTTON_Y,ROW[i]}, width = 3200, height = 2300, font_size = 1200, scale = {0.1,0.1,0.1}}
        if living[i].sane then
            buttonParam.label = 'Sane'
            buttonParam.font_color = stringColorToRGB('Blue')
            buttonParam.tooltip = 'Player is sane'
        else
            buttonParam.label = 'Mad'
            buttonParam.font_color = stringColorToRGB('Red')
            buttonParam.tooltip = 'Player is mad'
        end
        self.createButton(buttonParam)

        buttonParam = {click_function = 'remove'..i, function_owner = self, label = '✕', color = {0,0,0,1}, font_color = stringColorToRGB('Red'), position = {COLUMN[6],BUTTON_Y,ROW[i]}, width = 2300, height = 2300, scale = {0.1,0.1,0.1}, font_size = FONT_SIZE * 10, tooltip = 'Remove from list'}
        self.createButton(buttonParam)
    end

    if #order > 0 then
        buttonParam = {click_function = 'send', function_owner = self, label = removeUnder(order[1].char), color = {0,0,0,1}, font_color = COLORS_RGB[order[1].color], position = {COLUMN[7],BUTTON_Y,ROW[1]}, width = 1350, height = 230, font_size = FONT_SIZE,}
        self.createButton(buttonParam)

        buttonParam = {click_function = 'skip1', function_owner = self, label = 'Skip', color = {0,0,0,1}, font_color = stringColorToRGB('Red'), position = {COLUMN[8],BUTTON_Y,ROW[1]}, width = 675, height = 230, font_size = FONT_SIZE,}
        self.createButton(buttonParam)
    end

    for i = 2, #order do
        buttonParam = {click_function = 'nullFunc', function_owner = self, label = removeUnder(order[i].char), color = {0,0,0,1}, font_color = COLORS_RGB[order[i].color], position = {COLUMN[7],BUTTON_Y,ROW[i]}, width = 0, height = 0, font_size = FONT_SIZE,}
        self.createButton(buttonParam)

        buttonParam = {click_function = 'skip'..i, function_owner = self, label = 'Skip', color = {0,0,0,1}, font_color = stringColorToRGB('Red'), position = {COLUMN[8],BUTTON_Y,ROW[i]}, width = 675, height = 200, font_size = FONT_SIZE,}
        self.createButton(buttonParam)
    end

    buttonParam = {click_function = 'nullFunc', label = 'Preview', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {COLUMN[7],BUTTON_Y,PREVIEW_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE_LABEL,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = format(sendMsg), color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {COLUMN[7],BUTTON_Y,PREVIEW_MSG_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE,}
    self.createButton(buttonParam)


    buttonParam = {click_function = 'nullFunc', label = 'Add Character', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {ADDCHAR_LAB_X,BUTTON_Y,ADDCHAR_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE_LABEL,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = 'Character', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {INPUTS_X[1],BUTTON_Y,INPUTS_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE,}
    self.createButton(buttonParam)


    buttonParam = {click_function = 'nullFunc', label = 'Color', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {INPUTS_X[2],BUTTON_Y,INPUTS_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = 'Prompt 1', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {INPUTS_X[3],BUTTON_Y,INPUTS_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = 'Prompt 2', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {INPUTS_X[4],BUTTON_Y,INPUTS_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = 'Prompt 3', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {INPUTS_X[5],BUTTON_Y,INPUTS_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'addChar', label = '+', color = {1,1,1,1}, font_color = stringColorToRGB('Black'), function_owner = self, position = {ADD_BUT_X,BUTTON_Y,INPUT_BUT_Z}, rotation = {0,0,0}, width = 333, height = 333, font_size = FONT_SIZE, tooltip = 'Add character to game'}
    self.createButton(buttonParam)

    inputParam = {input_function = 'charInput', color = stringColorToRGB('Grey'), function_owner = self, font_color = {0,0,0}, function_owner = self,
        position = {INPUTS_X[1],BUTTON_Y,INPUT_BUT_Z}, rotation = {0,0,0}, width = 1800, height = 260, font_size = FONT_SIZE, value = charAdd, alignment = 3, validation = 1, tab = 2}
    self.createInput(inputParam)

    inputParam = {input_function = 'colorInput', color = stringColorToRGB('Grey'), function_owner = self, font_color = {0,0,0}, function_owner = self,
        position = {INPUTS_X[2],BUTTON_Y,INPUT_BUT_Z}, rotation = {0,0,0}, width = 900, height = 260, font_size = FONT_SIZE, value = colorAdd, alignment = 3, validation = 1, tab = 2}
    self.createInput(inputParam)

    inputParam = {input_function = 'p1Input', color = stringColorToRGB('Grey'), function_owner = self, font_color = {0,0,0}, function_owner = self,
        position = {INPUTS_X[3],BUTTON_Y,INPUT_BUT_Z}, rotation = {0,0,0}, width = 1500, height = 260, font_size = FONT_SIZE, value = p1, alignment = 3, validation = 1, tab = 2, label = 'P1'}
    self.createInput(inputParam)

    inputParam = {input_function = 'p2Input', color = stringColorToRGB('Grey'), function_owner = self, font_color = {0,0,0}, function_owner = self,
        position = {INPUTS_X[4],BUTTON_Y,INPUT_BUT_Z}, rotation = {0,0,0}, width = 1500, height = 260, font_size = FONT_SIZE, value = p2, alignment = 3, validation = 1, tab = 2, label = 'P2'}
    self.createInput(inputParam)

    inputParam = {input_function = 'p3Input', color = stringColorToRGB('Grey'), function_owner = self, font_color = {0,0,0}, function_owner = self,
        position = {INPUTS_X[5],BUTTON_Y,INPUT_BUT_Z}, rotation = {0,0,0}, width = 1500, height = 260, font_size = FONT_SIZE, value = p3, alignment = 3, validation = 1, tab = 2, label = 'P3'}
    self.createInput(inputParam)

    buttonParam = {click_function = 'import', label = 'Start', color = {1,1,1,1}, font_color = stringColorToRGB('Black'), function_owner = self, position = {BOTTOM_BUT_X[1],BUTTON_Y,BOTTOM_BUT_Z}, rotation = {0,0,0}, width = 1125, height = 800, font_size = FONT_SIZE, tooltip = 'Import characters\nfrom game'}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'firstNight', label = 'First\nNight', color = {1,1,1,1}, font_color = stringColorToRGB('Black'), function_owner = self, position = {BOTTOM_BUT_X[2],BUTTON_Y,BOTTOM_BUT_Z}, rotation = {0,0,0}, width = 1125, height = 800, font_size = FONT_SIZE, tooltip = 'Set night order\nfor first night'}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'otherNight', label = 'Other\nNights', color = {1,1,1,1}, font_color = stringColorToRGB('Black'), function_owner = self, position = {BOTTOM_BUT_X[3],BUTTON_Y,BOTTOM_BUT_Z}, rotation = {0,0,0}, width = 1125, height = 800, font_size = FONT_SIZE, tooltip = 'Set night order\nfor other nights'}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'toggleCheck', label = 'Check\nPrompts\nON', color = {1,1,1,1}, font_color = stringColorToRGB('Black'), function_owner = self, position = {BOTTOM_BUT_X[4],BUTTON_Y,BOTTOM_BUT_Z}, rotation = {0,0,0}, width = 1125, height = 800, font_size = FONT_SIZE, tooltip = 'Check if prompts have been filled in'}
    if not checkPrompts then
        buttonParam.label = 'Check\nPrompts\nOFF'
    end
    self.createButton(buttonParam)

    buttonParam = {click_function = 'toggleBlind', label = 'Auto\nBlindfold\nON', color = {1,1,1,1}, font_color = stringColorToRGB('Black'), function_owner = self, position = {BOTTOM_BUT_X[5],BUTTON_Y,BOTTOM_BUT_Z}, rotation = {0,0,0}, width = 1125, height = 800, font_size = FONT_SIZE, tooltip = 'Toggle Auto Blindfold'}
    if not blindAuto then
        buttonParam.label = 'Auto\nBlindfold\nOFF'
    end
    self.createButton(buttonParam)
end

function removeUnder(input)
    return string.gsub(input, '_', ' ')
end
